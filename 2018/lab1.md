# 实验报告

## 实验名称（测量FFT程序执行时间）

班级 学号 姓名

## 实验目标

测量FFT程序运行时间，确定时间复杂度理论分析结果O(nlogn)的细节。

## 实验要求

* 采用C/C++编写程序
* 根据自己的机器配置选择合适的输入数据大小 n，至少要测试多个不同的 n (参见思考题)
* 对于相同的 n，建议重复测量30次取平均值作为测量结果 (参见思考题)
* 对测量结果进行分析，确定时间复杂度理论分析结果O(nlogn)的细节

## 实验要求

1. 考虑理论分析FFT的时间复杂度为 O(nlogn)，那么FFT程序的具体执行时间公式可能是什么形式？
2. 根据上一点中的分析，至少要测试多少不同的 n 来确定执行时间公式中的未知数？
3. 重复30次测量然后取平均有什么统计学的依据？

## 实验内容

### FFT算法代码

CPU的指令集请见[这里](https://riscv.org/specifications/)，其中基本指令集共有_47_条指令。

### 模拟器程序框架

考虑到CPU执行指令的流程为：

1. 取指
2. 译码
3. 执行（包括运算和结果写回）

对模拟器程序的框架设计如下：

```C++
while(1) {
    inst = fetch(cpu.pc);
    cpu.pc = cpu.pc + 4;
    
    inst.decode();
    
    switch(inst.opcode) {
        case ADD:
            cpu.regs[inst.rd] = cpu.regs[rs] + cpu.regs[rt];
            break;
        case /*其它操作码*/ :
            /* 执行相关操作 */
            break;
        default:
            cout << "无法识别的操作码：” << inst.opcode;
    }
}
```

其中while循环条件可以根据需要改为模拟终止条件。

## 测试

### 测试平台

模拟器在如下机器上进行了测试：

| 部件     | 配置             | 备注   |
| :--------|:----------------:| :-----:|
| CPU      | core i5-6500U    |        |
| 内存     | DDR3 4GB         |        |
| 操作系统 | Ubuntu 18.04 LTS | 中文版 |

### 测试记录

模拟器的测试输入文件请见[这里](./test.input)。

模拟器运行过程的截图如下：

第一条指令运行后模拟器的输出

![图1](./perf_ls.png)

最后一条指令运行后模拟器的输出

![图2](./perf_ls.png)

## 分析和结论

从测试记录来看，模拟器实现了对二进制指令文件的读入，指令功能的模拟，CPU和存储器状态的输出。

根据分析结果，可以认为编写的模拟器实现了所要求的功能，完成了实验目标。

